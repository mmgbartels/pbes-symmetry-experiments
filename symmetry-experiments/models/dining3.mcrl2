% This is a specification of the dining philosophers problem (sequential version).

sort Phil = struct p1 | p2 | p3;
     Fork = struct f1 | f2 | f3;

map lf, rf: Phil -> Fork;
eqn lf(p1) = f1;
    lf(p2) = f2;
    lf(p3) = f3;
    rf(p1) = f3;
    rf(p2) = f1;
    rf(p3) = f2;

act get, put, up, down, lock, free: Fork;
    eat: Phil;

proc P_Phil(p: Phil) =
       (get(lf(p)).get(rf(p)) + get(rf(p)).get(lf(p))) . eat(p) .
       (put(lf(p)).put(rf(p)) + put(rf(p)).put(lf(p))) . P_Phil(p);
     P_Fork(f: Fork) = up(f) . down(f) . P_Fork(f);

init allow ( { lock, free, eat },
       comm( { get|up->lock, put|down->free },
         P_Fork(f1) || P_Fork(f2) || P_Fork(f3) ||
         P_Phil(p1) || P_Phil(p2) || P_Phil(p3)
     ));
