#![forbid(unsafe_code)]

use std::fmt;
use std::hash::Hash;
use std::hash::Hasher;

use merc_lts::LTS;
use merc_lts::LabelIndex;
use merc_lts::LabelledTransitionSystem;
use merc_lts::StateIndex;
use rustc_hash::FxHashSet;

use crate::BlockIndex;
use crate::Partition;
use crate::quotient_lts_naive;

use super::BlockPartition;
use super::sort_topological;
use super::tau_scc_decomposition;

/// The builder used to construct the signature.
pub type SignatureBuilder = Vec<(LabelIndex, BlockIndex)>;

/// The type of a signature. We use sorted vectors to avoid the overhead of hash
/// sets that might have unused values.
#[derive(Eq)]
pub struct Signature<'a>(&'a [(LabelIndex, BlockIndex)]);

impl<'a> Signature<'a> {
    pub fn new(slice: &'a [(LabelIndex, BlockIndex)]) -> Signature<'a> {
        Signature(slice)
    }

    pub fn as_slice(&self) -> &[(LabelIndex, BlockIndex)] {
        self.0
    }
}

impl Signature<'_> {
    // Check if target is a subset of self, excluding a specific element
    pub fn is_subset_of(&self, other: &[(LabelIndex, BlockIndex)], exclude: (LabelIndex, BlockIndex)) -> bool {
        let mut self_iter = self.as_slice().iter();
        let mut other_iter = other.iter().filter(|&&x| x != exclude);

        let mut self_item = self_iter.next();
        let mut other_item = other_iter.next();

        while let Some(&o) = other_item {
            match self_item {
                Some(&s) if s == o => {
                    // Match found, move both iterators forward
                    self_item = self_iter.next();
                    other_item = other_iter.next();
                }
                Some(&s) if s < o => {
                    // Move only self iterator forward
                    self_item = self_iter.next();
                }
                _ => {
                    // No match found in self for o
                    return false;
                }
            }
        }
        // If we finished self_iter without returning false, self is a subset
        true
    }
}

// This default implementation is actually different from the one generated by derive(Default).
#[allow(clippy::derivable_impls)]
impl Default for Signature<'_> {
    fn default() -> Self {
        Signature(&[])
    }
}

impl PartialEq for Signature<'_> {
    fn eq(&self, other: &Self) -> bool {
        self.as_slice() == other.as_slice()
    }
}

impl Hash for Signature<'_> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.as_slice().hash(state)
    }
}

impl fmt::Debug for Signature<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_list().entries(self.as_slice().iter()).finish()
    }
}

/// Returns true if the label is the special tau_hat label for the given LTS.
pub fn is_tau_hat(label: LabelIndex, lts: &impl LTS) -> bool {
    label == lts.num_of_labels()
}

/// Returns a special label that is not in the set of labels.
fn tau_hat(lts: &impl LTS) -> LabelIndex {
    LabelIndex::new(lts.num_of_labels())
}

/// Returns the signature for strong bisimulation.
///
/// ```plain
///     sig(s, pi) = { (a, pi(t)) | s -a-> t in T }
/// ```
pub fn strong_bisim_signature(
    state_index: StateIndex,
    lts: &impl LTS,
    partition: &impl Partition,
    builder: &mut SignatureBuilder,
) {
    builder.clear();

    for transition in lts.outgoing_transitions(state_index) {
        builder.push((transition.label, partition.block_number(transition.to)));
    }

    // Compute the flat signature, which has Hash and is more compact.
    builder.sort_unstable();
    builder.dedup();
}

/// Returns the branching bisimulation signature for branching bisimulation.
///
/// ```plain
///     sig(s, pi) = { (a, pi(t)) | s -tau-> s1 -> ... s_n -a-> t in T && pi(s) = pi(s_i) && ((a != tau) || pi(s) != pi(t)) }
/// ```
pub fn branching_bisim_signature(
    state_index: StateIndex,
    lts: &impl LTS,
    partition: &impl Partition,
    builder: &mut SignatureBuilder,
    visited: &mut FxHashSet<StateIndex>,
    stack: &mut Vec<StateIndex>,
) {
    // Clear the builders and the list of visited states.
    builder.clear();
    visited.clear();

    // A stack used for depth first search of tau paths.
    debug_assert!(stack.is_empty(), "The stack should be empty");
    stack.push(state_index);

    while let Some(inner_state_index) = stack.pop() {
        visited.insert(inner_state_index);

        for transition in lts.outgoing_transitions(inner_state_index) {
            if lts.is_hidden_label(transition.label) {
                if partition.block_number(state_index) == partition.block_number(transition.to) {
                    // Explore the outgoing state as well, still tau path in same block
                    if !visited.contains(&transition.to) {
                        visited.insert(transition.to);
                        stack.push(transition.to);
                    }
                } else {
                    //  pi(s) != pi(t)
                    builder.push((transition.label, partition.block_number(transition.to)));
                }
            } else {
                // (a != tau) This is a visible action only reachable from tau paths with equal signatures.
                builder.push((transition.label, partition.block_number(transition.to)));
            }
        }
    }

    // Compute the flat signature, which has Hash and is more compact.
    builder.sort_unstable();
    builder.dedup();
}

/// The same as [branching_bisim_signature], but assuming that the input LTS is
/// topological sorted, and contains no tau-cycles.
pub fn branching_bisim_signature_sorted(
    state_index: StateIndex,
    lts: &impl LTS,
    partition: &impl Partition,
    state_to_signature: &[Signature],
    builder: &mut SignatureBuilder,
) {
    builder.clear();

    for transition in lts.outgoing_transitions(state_index) {
        let to_block = partition.block_number(transition.to);

        if partition.block_number(state_index) == to_block {
            if lts.is_hidden_label(transition.label) {
                // Inert tau transition, take signature from the outgoing tau-transition.
                builder.extend(state_to_signature[transition.to].as_slice());
            } else {
                builder.push((transition.label, to_block));
            }
        } else {
            // Visible action, add to the signature.
            builder.push((transition.label, to_block));
        }
    }

    // Compute the flat signature, which has Hash and is more compact.
    builder.sort_unstable();
    builder.dedup();
}

/// The inductive version of [branching_bisim_signature_sorted]. Assumes that
/// the input LTS has no tau-cycles, and is topologically sorted.
pub fn branching_bisim_signature_inductive(
    state_index: StateIndex,
    lts: &impl LTS,
    partition: &BlockPartition,
    state_to_key: &[BlockIndex],
    builder: &mut SignatureBuilder,
) {
    builder.clear();

    for transition in lts.outgoing_transitions(state_index) {
        let to_block = partition.block_number(transition.to);

        if partition.block_number(state_index) == to_block {
            if lts.is_hidden_label(transition.label) && partition.is_element_marked(transition.to) {
                // Inert tau transition, take signature from the outgoing tau-transition.
                builder.push((tau_hat(lts), state_to_key[transition.to]));
            } else {
                builder.push((transition.label, to_block));
            }
        } else {
            // Visible action, add to the signature.
            builder.push((transition.label, to_block));
        }
    }

    // Compute the flat signature, which has Hash and is more compact.
    builder.sort_unstable();
    builder.dedup();
}

/// Computes the weak bisimulation signature.
///
/// The input lts must contain no tau-cycles.
pub fn weak_bisim_signature_sorted(
    state_index: StateIndex,
    lts: &impl LTS,
    partition: &impl Partition,
    state_to_signature: &[Signature],
    builder: &mut SignatureBuilder,
) {
    builder.clear();
    builder.push((LabelIndex::new(0), partition.block_number(state_index))); // Add the inert tau transition to itself.
    for transition in lts.outgoing_transitions(state_index) {
        let to_block = partition.block_number(transition.to);

        if lts.is_hidden_label(transition.label) {
            // Inert tau transition, take signature from the outgoing tau-transition.
            builder.extend(state_to_signature[transition.to].as_slice());
        } else {
            builder.push((transition.label, to_block));
            for (label_after, color) in state_to_signature[transition.to].as_slice() {
                if lts.is_hidden_label(*label_after) {
                    builder.push((transition.label, *color));
                }
            }
        }
    }

    // Compute the flat signature, which has Hash and is more compact.
    builder.sort_unstable();
    builder.dedup();
}

/// This computes only tau signatures.
///
/// The input lts must contain no tau-cycles.
pub fn weak_bisim_signature_sorted_taus(
    state_index: StateIndex,
    lts: &impl LTS,
    partition: &impl Partition,
    state_to_signature: &[Signature],
    builder: &mut SignatureBuilder,
) {
    builder.clear();
    builder.push((LabelIndex::new(0), partition.block_number(state_index))); // Add the inert tau transition to itself.
    for transition in lts.outgoing_transitions(state_index) {
        if lts.is_hidden_label(transition.label) {
            let to_block = partition.block_number(transition.to);

            // Inert tau transition, take signature from the outgoing tau-transition.
            builder.extend(state_to_signature[transition.to].as_slice());
            builder.push((transition.label, to_block));
        }
    }
    // Compute the flat signature, which has Hash and is more compact.
    builder.sort_unstable();
    builder.dedup();
}

/// Perform the preprocessing necessary for branching bisimulation with the
/// sorted signature see [branching_bisim_signature_sorted].
pub fn preprocess_branching<L: LTS>(lts: L) -> LabelledTransitionSystem<L::Label> {
    let scc_partition = tau_scc_decomposition(&lts);
    let tau_loop_free_lts = quotient_lts_naive(&lts, &scc_partition, true);
    drop(lts);

    // Sort the states according to the topological order of the tau transitions.
    let topological_permutation = sort_topological(
        &tau_loop_free_lts,
        |label_index, _| tau_loop_free_lts.is_hidden_label(label_index),
        true,
    )
    .expect("After quotienting, the LTS should not contain cycles");

    LabelledTransitionSystem::new_from_permutation(tau_loop_free_lts, |i| topological_permutation[i])
}
