//!
//! This contains the grammar for .mcrl2 specifications.
//!
//! Considerations for PEG parsers
//! 

//! AFTER parsing we can use a PrattParser to define the associativity and 
//! precedence of operators for rules of the following shape:
//!
//! expr  =   { prefix* ~ primary ~ postfix* ~ (infix ~ prefix* ~ primary ~ postfix* )* }
//!

//! The | operator defines a choice operator and does not mean OR with
//! backtracking. This means the following rules
//! 
//! Expr = { "Bool" ~ ASCII_ALPHANUMERIC* }
//!
//! Will match the expression "Boolean" by eating up "Bool" and leaving "ean" as
//! the remaining. However, this is undesirable since this should be an identifier
//! Boolean. This is resolved by only allowing keywords to match whenever it is not
//! by something that is part of an identifier.

/// This is a silent rule eating all the comments.
COMMENT = _{ "%" ~ (!NEWLINE ~ ANY)* }

/// This is a silent rule eating all the white space in the input.
WHITESPACE = _{ " " | "\t" | NEWLINE }

/// Identifiers
Id = @{ (ASCII_ALPHANUMERIC|"_"|"'")+ }

// Special identifiers
IdAt = @{ (ASCII_ALPHANUMERIC|"@"|"_"|"'")+ }

/// List of identifiers
IdList = { Id ~ ( "," ~ Id )* }

/// Numbers
Number = { ASCII_DIGIT+ }

/// Parsing an mCRL2 specification
MCRL2Spec = { SOI ~ (ActSpec | ConsSpec | EqnSpec | GlobVarSpec | ProcSpec | Init | MapSpec | SortSpec)* ~ EOI } 

/// Parsing an mCRL2 specification
DataSpec = { SOI ~ (ConsSpec | EqnSpec | MapSpec | SortSpec)* ~ EOI } 

/// Action specification
ActSpec = { "act" ~ ActDecl+ }

/// Declaration of actions
ActDecl = { IdList ~ ( ":" ~  SortProduct )? ~ ";" }

//
// Rules related to data expressions and sorts.
//

/// Sort specification
SortSpec = { "sort" ~ SortDecl+ } 

SortDecl = {                                             
        Id ~ "=" ~ SortExpr ~ ";"  // Sort alias  
    |   IdList ~ ";"               // List of sort identifiers                                               
}

/// A general sort expression with infix operators.
SortExpr = {
    SortExprPrimary ~ (SortExprInfix ~ SortExprPrimary)*
}

/// A single sort expression
SortExprPrimary = _{ 
      SortExprBool
    | SortExprPos                                                  
    | SortExprNat                                                  
    | SortExprInt                                                  
    | SortExprReal                                                
    | SortExprList
    | SortExprSet
    | SortExprBag
    | SortExprFSet
    | SortExprFBag
    | SortExprParens
    | SortExprStruct
    | Id
}
    SortExprBool = { "Bool" ~ !Id }
    SortExprPos  = { "Pos" ~ !Id }
    SortExprNat  = { "Nat" ~ !Id }
    SortExprInt  = { "Int" ~ !Id }
    SortExprReal = { "Real" ~ !Id }
    SortExprList = { "List" ~ "(" ~ SortExpr ~ ")" }
    SortExprSet = { "Set" ~ "(" ~ SortExpr ~ ")" }
    SortExprBag  = { "Bag" ~ "(" ~ SortExpr ~ ")" }
    SortExprFSet = { "FSet" ~ "(" ~ SortExpr ~ ")" }
    SortExprFBag = { "FBag" ~ "(" ~ SortExpr ~ ")" }
    SortExprParens = { "(" ~ SortExpr ~ ")" }
    SortExprStruct = { "struct" ~ ConstrDeclList }

SortExprInfix = _{
    |   SortExprFunction
    |   SortExprProduct
}
    SortExprFunction = { "->" }
    SortExprProduct = { "#" }

/// Constructor declaration
ConstrDecl = { Id ~ ( "(" ~ ProjDeclList ~ ")" )? ~ ( "?" ~ Id )? } 

/// Constructor declaration list
ConstrDeclList = { ConstrDecl ~ ( "|" ~ ConstrDecl )* }             

/// A single sort A -> B -> ...
SortProduct = {
    SortExprPrimary ~ (SortExprProduct ~ SortExprPrimary)*
}

/// Data Expression
DataExpr = { DataExprPrefix* ~ DataExprPrimary ~ DataExprPostfix* ~ (DataExprInfix ~ DataExprPrefix* ~ DataExprPrimary ~ DataExprPostfix*)* }

/// Data Expressions without infix operators
DataExprUnit = { DataExprPrefix* ~ DataExprPrimary ~ DataExprPostfix* }

// A data expression prefix
DataExprPrefix = _{
    | DataExprNegation
    | DataExprMinus
    | DataExprSize
    | DataExprForall
    | DataExprExists
    | DataExprLambda
}
    DataExprForall = { "forall" ~ VarsDeclList ~ "." }
    DataExprExists = { "exists" ~ VarsDeclList ~ "." }
    DataExprLambda = { "lambda" ~ VarsDeclList ~ "." }
    DataExprNegation = { "!" }
    DataExprMinus = { "-" }
    DataExprSize = { "#"  }

// A single data expressions
DataExprPrimary = _{
      DataExprTrue
    | DataExprFalse
    | DataExprEmptyList
    | DataExprEmptySet
    | DataExprEmptyBag
    | DataExprListEnum
    | DataExprBagEnum
    | DataExprSetBagComp
    | DataExprSetEnum
    | DataExprBrackets
    | Number
    | Id
}
    DataExprTrue = { "true" ~ !Id }
    DataExprFalse = { "false" ~ !Id }
    DataExprEmptyList = { "[" ~ "]" }
    DataExprEmptySet = { "{" ~ "}" }
    DataExprEmptyBag = { "{" ~ ":" ~ "}" }
    DataExprListEnum = { "[" ~ DataExprList ~ "]" }
    DataExprBagEnum = { "{" ~ BagEnumEltList ~ "}" }
    DataExprSetBagComp = { "{" ~ VarDecl ~ "|" ~ DataExpr ~ "}" }
    DataExprSetEnum = { "{" ~ DataExprList ~ "}" }
    DataExprBrackets = { "(" ~ DataExpr ~ ")" }

DataExprPostfix = _{
      DataExprUpdate
    | DataExprApplication
    | DataExprWhr
}
    DataExprUpdate = { "[" ~ DataExpr ~ "->" ~ DataExpr ~ "]" }
    DataExprApplication = { "(" ~ DataExprList ~ ")" }
    DataExprWhr = { "whr" ~ AssignmentList ~ "end" }

DataExprInfix = _{
      DataExprImpl
    | DataExprDisj
    | DataExprConj
    | DataExprEq
    | DataExprNeq
    | DataExprLeq
    | DataExprSnoc
    | DataExprLess
    | DataExprGeq
    | DataExprGreater
    | DataExprIn
    | DataExprCons
    | DataExprConcat
    | DataExprAdd
    | DataExprSubtract
    | DataExprDiv
    | DataExprIntDiv
    | DataExprMod
    | DataExprMult
    | DataExprAt
}
    DataExprImpl    = { "=>" }
    DataExprDisj    = { "||" }
    DataExprConj    = { "&&" }
    DataExprEq      = { "==" }
    DataExprNeq     = { "!=" }
    DataExprLeq     = { "<=" }
    DataExprSnoc    = { "<|" }
    DataExprLess    = { "<" ~ !">" }
    DataExprGeq     = { ">=" }
    DataExprGreater = { ">" }
    DataExprIn      = { "in" }
    DataExprCons    = { "|>" }
    DataExprConcat  = { "++" }
    DataExprAdd     = { "+" }
    DataExprSubtract = { "-" ~ !">" }
    DataExprDiv     = { "/" }
    DataExprIntDiv  = { "div" }
    DataExprMod     = { "mod" }
    DataExprMult    = { "*" }
    DataExprAt      = { "." }

/// List of data expressions
DataExprList = { DataExpr ~ ( "," ~ DataExpr )* }

/// Assignment x = expression
Assignment = { Id ~ "=" ~ DataExpr }

/// List of assignments
AssignmentList = { Assignment ~ ( "," ~ Assignment )* }

//
// Rules related to processes.
//

/// Typed variable
VarDecl = { Id ~ ":" ~ SortExpr }

/// Typed variables
VarsDecl = { IdList ~ ":" ~ SortExpr }

/// Individually typed variables
VarsDeclList = { VarsDecl ~ ( "," ~ VarsDecl )* }

/// Bag element with multiplicity
BagEnumElt = { DataExpr ~ ":" ~ DataExpr }                              

/// Elements in a finite bag
BagEnumEltList = { BagEnumElt ~ ( "," ~ BagEnumElt )* }

/// Action, process instantiation
Action = { Id ~ ( "(" ~ DataExprList ~ ")" )? }    

/// Action set        
ActIdSet = { "{" ~ IdList ~ "}" }                                               

/// Multi-action label
MultActId = { Id ~ ( "|" ~ Id )* }                                      

MultActIdList = { MultActId ~ ( "," ~ MultActId )* }

/// Multi-action label set
MultActIdSet = { "{" ~ MultActIdList? ~ "}" }

/// Domain with optional projection
ProjDecl = { ( Id ~ ":" )? ~ SortExpr }                             

/// Declaration of projection functions
ProjDeclList = { ProjDecl ~ ( "," ~ ProjDecl )* }                  

/// Action synchronization
CommExpr = { Id ~ "|" ~ MultActId ~ "->" ~ Id }

/// Action synchronizations
CommExprList = { CommExpr ~ ( "," ~ CommExpr )* }

/// Action synchronization set
CommExprSet = { "{" ~ CommExprList? ~ "}" }                             

/// Action renaming
RenExpr = { Id ~ "->" ~ Id }

/// Multiple action renamings
RenExprList = { RenExpr ~ ( "," ~ RenExpr )* }

/// An action renaming set.
RenExprSet = { "{" ~ RenExprList? ~ "}" }

ProcExpr = { ProcExprPrefix* ~ ProcExprPrimary ~ ProcExprPostfix? ~ (ProcExprInfix ~ ProcExprPrefix* ~ ProcExprPrimary ~ ProcExprPostfix?)* }

/// Single Process expressions
ProcExprPrimary = _{
      ProcExprDelta
    | ProcExprTau
    | ProcExprBlock
    | ProcExprAllow
    | ProcExprHide
    | ProcExprRename
    | ProcExprComm
    | ProcExprBrackets
    | ProcExprId
    | Action
}
    ProcExprDelta = { "delta" ~ !Id }                                            // Delta, deadlock, inaction
    ProcExprTau = { "tau" ~ !Id }                                                // Tau, hidden action, empty multi-action
    ProcExprBlock = { "block" ~ "(" ~ ActIdSet ~ "," ~ ProcExpr ~ ")" }          // Block or encapsulation operator
    ProcExprAllow = { "allow" ~ "(" ~ MultActIdSet ~ "," ~ ProcExpr ~ ")" }      // Allow operator
    ProcExprHide = { "hide" ~ "(" ~ ActIdSet ~ "," ~ ProcExpr ~ ")" }            // Hiding operator
    ProcExprRename = { "rename" ~ "(" ~ RenExprSet ~ "," ~ ProcExpr ~ ")" }      // Action renaming operator
    ProcExprComm = { "comm" ~ "(" ~ CommExprSet ~ "," ~ ProcExpr ~ ")" }         // Communication operator
    ProcExprBrackets = { "(" ~ ProcExpr ~ ")" }                                  // Brackets
    ProcExprId = { Id ~ "(" ~ AssignmentList? ~ ")" }                            // Process instantiation with assignment shorthand

ProcExprPrefix = _{
    | ProcExprSum
    | ProcExprDist 
    | ProcExprIfThen 
    | ProcExprIf
}
    ProcExprSum = { "sum" ~ VarsDeclList ~ "." }
    ProcExprDist = { "dist" ~ VarsDeclList ~ "[" ~ DataExpr ~ "]" ~ "." }
    ProcExprIfThen = { DataExpr ~ "->" ~ ProcExprNoIf ~ "<>" }
    ProcExprIf = { DataExpr ~ "->" }

ProcExprInfix = _{
      ProcExprChoice
    | ProcExprLeftMerge
    | ProcExprParallel
    | ProcExprSeq
    | ProcExprUntil
    | ProcExprSync
}
    ProcExprChoice = { "+" } 
    ProcExprLeftMerge = { "||_" }
    ProcExprParallel = { "||" }
    ProcExprSeq = { "." }
    ProcExprUntil = { "<<" }
    ProcExprSync = { "|" }

ProcExprPostfix = _{
    ProcExprAt 
}
    ProcExprAt = { "@" ~ DataExprUnit }
    
ProcExprNoIf = { ProcExprPrefix* ~ ProcExprPrimary ~ ProcExprPostfix? ~ (ProcExprNoIfInfix ~ ProcExprPrefix* ~ ProcExprPrimary ~ ProcExprPostfix?)* }

ProcExprNoIfInfix = _{
    | ProcExprChoice
    | ProcExprLeftMerge
    | ProcExprParallel
    | ProcExprSeq
    | ProcExprUntil
    | ProcExprSync
    | ProcExprIfThen
}

// Process declaration/
ProcDecl = { Id ~ ( "(" ~ VarsDeclList ~ ")" )? ~ "=" ~ ProcExpr ~ ";" }

/// Process specification
ProcSpec = { "proc" ~ ProcDecl+ }                                     

/// Initial process
Init = { "init" ~ ProcExpr ~ ";" }   

/// Typed parameters
IdsDecl = { IdList ~ ":" ~ SortExpr }                                   

/// Declaration of constructors
ConsSpec = { "cons" ~ ( IdsDecl ~ ";" )+ }

/// Declaration of mappings
MapSpec = { "map" ~ ( IdsDecl ~ ";" )+ }    

/// Declaration of global variables
GlobVarSpec = { "glob" ~ ( VarsDeclList ~ ";" )+ }                     
 
/// Declaration of variables      
VarSpec = { "var" ~ ( VarsDeclList ~ ";" )+ }                                               

/// Definition of equations
EqnSpec = { VarSpec? ~ "eqn" ~ EqnDecl+ }                               

/// Conditional equation
EqnDecl = { (DataExpr ~ "->")? ~ DataExpr ~ "=" ~ DataExpr ~ ";" }            


//
// Rules related to modal formulas
//

/// Single state formula or state formula specification
StateFrmSpec = {
    SOI ~ ((StateFrmSpecElt* ~ FormSpec ~ StateFrmSpecElt*) | StateFrm) ~ EOI
}

FormSpec = { "form" ~ StateFrm ~ ";" }

StateFrmSpecElt = {
      SortSpec                                                     // Sort specification
    | ConsSpec                                                     // Constructor specification
    | MapSpec                                                      // Map specification
    | EqnSpec                                                      // Equation specification
    | ActSpec                                                      // Action specification
}

StateFrm = { StateFrmPrefix* ~ StateFrmPrimary ~ StateFrmPostfix* ~ (StateFrmInfix ~ StateFrmPrefix* ~ StateFrmPrimary ~ StateFrmPostfix*)*}

StateFrmPrimary = _{
      StateFrmBrackets
    | StateFrmTrue
    | StateFrmFalse
    | StateFrmDelay
    | StateFrmYaled
    | StateFrmId
    | StateFrmDataValExpr
}
    StateFrmBrackets = { "(" ~ StateFrm ~ ")" }
    StateFrmTrue = { "true" }                                                       // True, can also be infinity
    StateFrmFalse = { "false" }                                                     // False, can also be minus infinity
    StateFrmDelay = { "delay" ~ ( "@" ~ DataExpr )? }
    StateFrmYaled = { "yaled" ~ ( "@" ~ DataExpr )? }
    StateFrmId = { Id ~ ( "(" ~ DataExprList ~ ")" )? }                             // Instantiated fixpoint variable
    StateFrmDataValExpr = { DataValExpr }

StateFrmPrefix = _{
    | StateFrmUnaryMinus
    | StateFrmMu
    | StateFrmNu
    | StateFrmForall
    | StateFrmExists
    | StateFrmInf
    | StateFrmSup
    | StateFrmSum
    | StateFrmDiamond
    | StateFrmBox
    | StateFrmNegation
    | StateFrmLeftConstantMultiply
}
    StateFrmMu = { "mu" ~ StateVarDecl ~ "." }                           // Minimal fixed point
    StateFrmNu = { "nu" ~ StateVarDecl ~ "." }                           // Maximal fixed point
    StateFrmInf = { "inf" ~ VarsDeclList ~ "." }                         // The infimum operator
    StateFrmSup = { "sup" ~ VarsDeclList ~ "." }                         // The supremum operator
    StateFrmSum = { "sum" ~ VarsDeclList ~ "." }                         // The supremum operator
    StateFrmForall = { "forall" ~ VarsDeclList ~ "." }                   // Universal quantification
    StateFrmExists = { "exists" ~ VarsDeclList ~ "." }                   // Existential quantification
    StateFrmBox = { "[" ~ RegFrm ~ "]" }                                 // Box modality
    StateFrmDiamond = { "<" ~ RegFrm ~ ">" }                             // Diamond modality
    StateFrmUnaryMinus = { "-" }                                         // Unary minus
    StateFrmNegation = { "!" }                                           // Negation
    StateFrmLeftConstantMultiply = { DataValExpr ~ "*" }
    

StateFrmInfix = _{
      StateFrmAddition
    | StateFrmImplication
    | StateFrmDisjunction
    | StateFrmConjunction
}
    StateFrmAddition = { "+" }
    StateFrmImplication = { "=>" }
    StateFrmDisjunction = { "||" }                                                   // Disjunction, and max
    StateFrmConjunction = { "&&" }                                                   // Conjunction, and min

StateFrmPostfix = _{
    StateFrmRightConstantMultiply   
}
    StateFrmRightConstantMultiply = { "*" ~ DataValExpr }

/// Regular formulas.
/// To guard for the ambiguity of a + b and a+ we use a negative premise
RegFrm = { RegFrmPrimary ~ (RegFrmPostfix ~ !ActFrm)? ~ (RegFrmInfix ~ RegFrmPrimary ~ (RegFrmPostfix ~ !ActFrm)?)* }

RegFrmPrimary = _{
      ActFrm
    | RegFrmBackets
}
    RegFrmBackets = { "(" ~ RegFrm ~ ")" }

RegFrmInfix = _{
       RegFrmAlternative
    |  RegFrmComposition
}
    RegFrmAlternative = { "+" }
    RegFrmComposition = { "." }

RegFrmPostfix = _{
      RegFrmIteration
    | RegFrmPlus
}
    RegFrmIteration = { "*" }
    RegFrmPlus = { "+" }


ActFrm = { ActFrmPrefix* ~ ActFrmPrimary ~ ActFrmPostfix* ~ (ActFrmInfix ~ ActFrmPrefix* ~ ActFrmPrimary ~ ActFrmPostfix*)* }

ActFrmPrimary = _{
      ActFrmBrackets
    | ActFrmTrue
    | ActFrmFalse
    | DataValExpr
    | MultAct
}
    ActFrmBrackets = { "(" ~ ActFrm ~ ")" }
    ActFrmTrue = { "true" }
    ActFrmFalse = { "false" }

ActFrmPrefix = _{
      ActFrmNegation
    | ActFrmForall
    | ActFrmExists
}
    ActFrmNegation = { "!" }
    ActFrmForall = { "forall" ~ VarsDeclList ~ "." }
    ActFrmExists = { "exists" ~ VarsDeclList ~ "." }

ActFrmInfix = _{
      ActFrmImplies
    | ActFrmUnion
    | ActFrmIntersect
}
    ActFrmImplies = { "=>" }
    ActFrmUnion = { "||" }
    ActFrmIntersect = { "&&" }

ActFrmPostfix = _{
    ActFrmAt
}
    ActFrmAt = { "@" ~ DataExpr }

MultAct = {
      MultiActTau                                              // Tau, hidden action, empty multi-action
    | ActionList                                               // Multi-action
}
    MultiActTau = { "tau" }

ActionList = { Action ~ ( "|" ~ Action )* }                      // List of actions

/// Marked data exression
DataValExpr = { "val" ~ "(" ~ DataExpr ~ ")" }                  

/// State variable declaration
StateVarDecl = { Id ~ ( "(" ~ StateVarAssignmentList ~ ")" )? }           

/// Typed variable with initial value
StateVarAssignment = { Id ~ ":" ~ SortExpr ~ "=" ~ DataExpr }           

/// Typed variable list
StateVarAssignmentList = { StateVarAssignment ~ ( "," ~ StateVarAssignment )* }

//
// Rules for action rename specifications
//
  
/// Action rename specification
ActionRenameSpec = { SOI ~ (SortSpec | ConsSpec | MapSpec | EqnSpec | ActSpec | ActionRenameRuleSpec)+ ~ EOI }

/// Action rename rule section
ActionRenameRuleSpec = { VarSpec? ~ "rename" ~ ActionRenameRule+ }      

/// Conditional action renaming
ActionRenameRule = { (DataExpr ~ "->")? ~ Action ~ "=>" ~ ActionRenameRuleRHS ~ ";" }

ActionRenameRuleRHS = {
      "tau"                                                        // Tau, hidden action, empty multi-action
    | "delta"                                                      // Delta, deadlock, inaction
    |  Action                                                      // Action
}

FixedPointOperator = { FixedPointMu | FixedPointNu }
    FixedPointMu = { "mu" }
    FixedPointNu = { "nu" }

/// Parameterised boolean equations systems
PbesSpec = { SOI ~ DataSpec? ~ GlobVarSpec? ~ PbesEqnSpec ~ PbesInit ~ EOI }

PbesEqnSpec = { "pbes" ~ PbesEqnDecl+ }

PbesEqnDecl = { FixedPointOperator ~ PropVarDecl ~ "=" ~ PbesExpr ~ ";" }

PropVarDecl = { Id ~ ("(" ~ VarsDeclList ~ ")")? }

PropVarInst = { Id ~ ("(" ~ DataExprList ~ ")")? }

PbesInit = { "init" ~ PropVarInst ~ ";" }

PbesExpr = { PbesExprPrefix* ~ PbesExprPrimary ~ (PbesExprInfix ~ PbesExprPrefix* ~ PbesExprPrimary)* }

PbesExprPrimary = _{
      DataValExpr
    | PbesExprParens
    | PbesExprTrue
    | PbesExprFalse
    | PropVarInst    
}
    PbesExprParens = { "(" ~ PbesExpr ~ ")" }
    PbesExprTrue = { "true" }
    PbesExprFalse = { "false" }

PbesExprPrefix = _{
      PbesExprForall
    | PbesExprExists
    | PbesExprNegation
}
    PbesExprForall = { "forall" ~ VarsDeclList ~ "." }
    PbesExprExists = { "exists" ~ VarsDeclList ~ "." }
    PbesExprNegation = { "!" }

PbesExprInfix = _{
      PbesExprImplies
    | PbesExprDisj
    | PbesExprConj   
}
    PbesExprImplies = { "=>" }
    PbesExprConj = { "&&" }
    PbesExprDisj = { "||" }

    
/// Parameterised boolean equations systems
PresExpr = { PresExprPrefix* ~ PresExprPrimary ~ PresExprPostfix* ~ (PresExprPrefix* ~ PresExprPrimary ~ PresExprPostfix*)* }

PresExprPrimary = _{
      DataValExpr
    | PresExprParens
    | PbesExprTrue
    | PbesExprFalse
    | PropVarInst    
    | PresExprEqinf
    | PresExprEqninf
    | PresExprCondsm
    | PresExprCondeq
}
    PresExprParens = { "(" ~ PresExpr ~ ")" }
    PresExprEqinf = { "eqinf" ~ "(" ~ PresExpr ~ ")" }
    PresExprEqninf = { "eqninf" ~ "(" ~ PresExpr ~ ")" }
    PresExprCondsm = { "condsm" ~ "(" ~ PresExpr ~ "," ~ PresExpr ~ "," ~ PresExpr ~ ")" }
    PresExprCondeq = { "condeq" ~ "(" ~ PresExpr ~ "," ~ PresExpr ~ "," ~ PresExpr ~ ")" }

PresExprPrefix = _{
      PresExprInf
    | PresExprSup
    | PresExprSum
    | PbesExprNegation
    | PresExprLeftConstantMultiply
}
    PresExprInf = { "inf" ~ VarsDeclList ~ "." }
    PresExprSup = { "sup" ~ VarsDeclList ~ "." }
    PresExprSum = { "sum" ~ VarsDeclList ~ "." }
    PresExprLeftConstantMultiply = { "*" }

PresExprInfix = _{
      PbesExprImplies
    | PbesExprDisj
    | PbesExprConj   
    | PresExprAdd  
}
    PresExprAdd = { "+" }

PresExprPostfix = _{
    PresExprRightConstMultiply
}
    PresExprRightConstMultiply = { "*" }